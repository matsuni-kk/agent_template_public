---
description: Chrome拡張Background Service Worker実装システム
globs:
alwaysApply: false
---
# ==========================================================
# 04_chrome_extension_background.mdc - Background Service Worker実装
# ==========================================================

path_reference: "chrome_extension_paths.mdc"

# ======== プロンプト（目的と使い方） ========
prompt_purpose: |
  Chrome拡張開発者がManifest V3のService Workerを実装し、永続的なバックグラウンド処理、イベント監視、Popup/Content Scriptとのメッセージング機能を構築します。

prompt_why_questions: |
  バックグラウンドで実行する処理（タブ監視、通知表示、データ同期等）、イベントリスナー設定、メッセージング要件を収集することで、拡張機能の中核となる制御ロジックを設計します。

prompt_why_templates: |
  Manifest V3のService Worker（イベント駆動型、非永続的）のテンプレートを提供することで、Manifest V2からの移行ポイント（background.scripts → background.service_worker）を明確化し、正しい実装パターンを即座に適用できます。

prompt_principles: |
  - Manifest V3のService Worker仕様準拠（イベント駆動型、非永続的）
  - Manifest V2からの移行時はAlarms APIを用いた定期実行への置き換え
  - 不足情報は「未記載」として明示
  - メッセージング設計（Popup↔Background↔Content Script）を明確化
  - 出典URL・取得日時を記録

# ======== Background Service Worker実装システム統合エージェント ========

system_capabilities:
  service_worker_architecture: "Manifest V3のイベント駆動型Service Workerを実装し、拡張インストール/更新、タブ操作、メッセージ受信等のイベントリスナーを登録"
  lifecycle_management: "Service Workerのライフサイクル管理（インストール、アクティベーション、アイドル時の自動停止）を制御し、状態永続化にStorage APIを活用"
  messaging_hub: "Popup UIとContent Scriptからのメッセージを受信・処理し、各コンポーネント間の通信ハブとして機能"
  chrome_api_orchestration: "Tabs API、Notifications API、Alarms API、Scripting APIなど複数のChrome APIを統合的に制御"
  event_handling: "chrome.runtime.onInstalled、chrome.tabs.onUpdated、chrome.alarms.onAlarm等のイベントを監視し、適切な処理を実行"
  state_persistence: "非永続的なService Workerの特性を考慮し、重要な状態をChrome Storage APIで永続化"

# ======== Phase 1: バックグラウンド処理要件収集フェーズ ========

phase_1_description: |
  バックグラウンドで実行する処理内容（タブ監視、定期実行タスク、通知表示等）を収集します。
  PopupやContent Scriptからのメッセージ受信時の処理内容を確認します。
  Manifest V2からの移行時は、setInterval/setTimeoutをAlarms APIに置き換える必要があることを説明します。

# ======== Phase 2: Service Worker実装フェーズ ========

phase_2_description: |
  収集した要件に基づき、background.jsを生成します。
  chrome.runtime.onInstalled、chrome.runtime.onMessage、chrome.tabs.onUpdated等のイベントリスナーを実装します。
  必要に応じてchrome.alarms APIを用いた定期実行タスクを実装します。

# ======== 統合オプション質問 ========

background_questions:
  - key: "background_features"
    prompt: "バックグラウンドで実行する機能を選択してください（カンマ区切り）:\n- tab_monitoring: タブの監視・操作\n- messaging: PopupやContent Scriptとのメッセージング\n- notifications: 通知表示\n- periodic_tasks: 定期実行タスク（Alarms API使用）\n- context_menu: 右クリックメニュー\n- storage_management: ストレージ管理"
    type: "text"
    required: true
    placeholder: "例: tab_monitoring,messaging,notifications"

  - key: "install_actions"
    prompt: "拡張インストール時の初期化処理を実装しますか？ (yes/no)\n例: デフォルト設定の保存、初回起動時の通知表示等"
    type: "text"
    required: true
    placeholder: "yes"

  - key: "message_types"
    prompt: "受信するメッセージタイプを入力してください（カンマ区切り）:\n例: TOGGLE_STATE, UPDATE_VALUE, EXECUTE_ACTION"
    type: "text"
    required: false
    placeholder: "例: TOGGLE_STATE,EXECUTE_ACTION"

  - key: "use_alarms_api"
    prompt: "定期実行タスク（Alarms API）を使用しますか？ (yes/no)"
    type: "text"
    required: false
    placeholder: "no"

  - key: "alarm_interval"
    prompt: "定期実行の間隔を分単位で入力してください（Alarms API使用時）："
    type: "text"
    required: false
    placeholder: "例: 5"

  - key: "use_context_menu"
    prompt: "右クリックメニュー（Context Menu）を追加しますか？ (yes/no)"
    type: "text"
    required: false
    placeholder: "no"

# ======== Background Service Worker実装プロセス ========

background_implementation_steps:
  1_event_listeners_setup:
    name: "イベントリスナー登録"
    phases:
      - "chrome.runtime.onInstalled イベントで初期化処理を実装"
      - "chrome.runtime.onMessage でメッセージ受信処理を実装"
      - "chrome.tabs.onUpdated でタブ更新監視を実装（必要に応じて）"
      - "chrome.alarms.onAlarm で定期実行タスクを実装（必要に応じて）"
      - "chrome.contextMenus.onClicked で右クリックメニュー処理を実装（必要に応じて）"
    quality_standards:
      - "全イベントリスナーをトップレベルで登録（Service Worker起動時に即座に登録）"
      - "非同期処理にasync/awaitを使用"

  2_messaging_implementation:
    name: "メッセージング機能実装"
    phases:
      - "chrome.runtime.onMessage で受信したメッセージタイプを判別"
      - "各メッセージタイプに応じた処理を実行"
      - "sendResponse でPopup/Content Scriptへレスポンスを返信"
      - "エラーハンドリングを実装"
    integration_points:
      - "Popup UIからのメッセージ受信（03_chrome_extension_popup.mdc）"
      - "Content Scriptからのメッセージ受信（05_chrome_extension_content.mdc）"

  3_state_management:
    name: "状態永続化"
    phases:
      - "Chrome Storage API（chrome.storage.sync または chrome.storage.local）で重要な状態を保存"
      - "Service Worker再起動時に状態を復元"
      - "拡張機能の有効/無効状態、ユーザー設定値を永続化"
    automation_features:
      - "定期的にストレージのバックアップを実施"

# ======== Backgroundワークフロー ========

background_workflow:
  phase_1:
    - name: "バックグラウンド処理要件収集"
      action: "call 04_chrome_extension_background.mdc => background_questions"
      description: "実装する機能とイベントリスナーを決定"
      mandatory: true

  phase_2:
    - name: "background.js生成"
      action: "create_file"
      description: "Service Workerスクリプトを src/js/ に生成"
      mandatory: true

    - name: "実装メモ保存"
      action: "create_markdown_file"
      description: "Flow側にBackground実装メモを保存"
      mandatory: true

# ======== テンプレート ========

background_js_template: |
  // background.js - Service Worker (Manifest V3)

  // インストール時の初期化処理
  {{#if install_actions}}
  chrome.runtime.onInstalled.addListener(async (details) => {
    console.log('Extension installed:', details);

    if (details.reason === 'install') {
      // 初回インストール時の処理
      await chrome.storage.sync.set({
        enabled: true,
        version: '1.0.0'
      });

      {{#if background_features.includes('notifications')}}
      chrome.notifications.create({
        type: 'basic',
        iconUrl: '../images/icon48.png',
        title: '拡張機能がインストールされました',
        message: 'ご利用ありがとうございます。'
      });
      {{/if}}
    } else if (details.reason === 'update') {
      // アップデート時の処理
      console.log('Extension updated to version:', chrome.runtime.getManifest().version);
    }

    {{#if use_context_menu}}
    // 右クリックメニューの登録
    chrome.contextMenus.create({
      id: 'action-menu',
      title: 'アクションを実行',
      contexts: ['page', 'selection']
    });
    {{/if}}
  });
  {{/if}}

  {{#if background_features.includes('messaging')}}
  // メッセージ受信処理
  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    console.log('Message received:', message, 'from:', sender);

    {{#if message_types}}
    switch (message.type) {
      {{#each message_types as |msgType|}}
      case '{{msgType}}':
        handle{{msgType}}(message, sender)
          .then(result => sendResponse({ success: true, data: result }))
          .catch(error => {
            console.error('{{msgType}} failed:', error);
            sendResponse({ success: false, error: error.message });
          });
        return true; // 非同期レスポンス用

      {{/each}}
      default:
        console.warn('Unknown message type:', message.type);
        sendResponse({ success: false, error: 'Unknown message type' });
    }
    {{else}}
    // メッセージ処理のサンプル
    if (message.type === 'EXECUTE_ACTION') {
      executeAction(message)
        .then(result => sendResponse({ success: true, data: result }))
        .catch(error => sendResponse({ success: false, error: error.message }));
      return true; // 非同期レスポンス用
    }
    {{/if}}
  });
  {{/if}}

  {{#if background_features.includes('tab_monitoring')}}
  // タブ更新監視
  chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
    if (changeInfo.status === 'complete' && tab.url) {
      console.log('Tab loaded:', tab.url);

      // タブロード完了時の処理
      handleTabLoaded(tabId, tab);
    }
  });

  async function handleTabLoaded(tabId, tab) {
    try {
      // 拡張機能が有効か確認
      const data = await chrome.storage.sync.get(['enabled']);
      if (!data.enabled) {
        return;
      }

      // Content Scriptへメッセージ送信（必要に応じて）
      chrome.tabs.sendMessage(tabId, {
        type: 'TAB_LOADED',
        url: tab.url
      });
    } catch (error) {
      console.error('handleTabLoaded failed:', error);
    }
  }
  {{/if}}

  {{#if use_alarms_api}}
  // Alarms API - 定期実行タスク
  chrome.alarms.create('periodicTask', {
    periodInMinutes: {{alarm_interval}}
  });

  chrome.alarms.onAlarm.addListener((alarm) => {
    console.log('Alarm triggered:', alarm.name);

    if (alarm.name === 'periodicTask') {
      executePeriodicTask();
    }
  });

  async function executePeriodicTask() {
    console.log('Executing periodic task...');

    try {
      // 定期実行する処理を実装
      const data = await chrome.storage.sync.get(['enabled']);
      if (data.enabled) {
        // 処理内容
        console.log('Periodic task executed');
      }
    } catch (error) {
      console.error('Periodic task failed:', error);
    }
  }
  {{/if}}

  {{#if use_context_menu}}
  // 右クリックメニュークリック処理
  chrome.contextMenus.onClicked.addListener((info, tab) => {
    console.log('Context menu clicked:', info.menuItemId);

    if (info.menuItemId === 'action-menu') {
      executeContextMenuAction(info, tab);
    }
  });

  async function executeContextMenuAction(info, tab) {
    try {
      console.log('Context menu action:', info.selectionText);

      // 選択テキストやページURLを使った処理
      {{#if background_features.includes('notifications')}}
      chrome.notifications.create({
        type: 'basic',
        iconUrl: '../images/icon48.png',
        title: 'アクション実行',
        message: `選択テキスト: ${info.selectionText || 'なし'}`
      });
      {{/if}}
    } catch (error) {
      console.error('Context menu action failed:', error);
    }
  }
  {{/if}}

  // メッセージハンドラー関数群
  {{#each message_types as |msgType|}}
  async function handle{{msgType}}(message, sender) {
    console.log('Handling {{msgType}}:', message);

    // {{msgType}} の処理をここに実装
    // 例:
    // - ストレージの更新
    // - Content Scriptへのメッセージ送信
    // - 外部APIへのリクエスト

    return { result: '{{msgType}} processed' };
  }

  {{/each}}

  async function executeAction(message) {
    console.log('Executing action:', message);

    // アクション実行処理をここに実装

    return { result: 'Action executed' };
  }

  // Service Workerのライフサイクルログ
  console.log('Service Worker initialized:', new Date().toISOString());

background_implementation_memo_template: |
  # Background Service Worker実装メモ - {{meta.timestamp}}

  ## 基本情報
  - **実装機能**: {{background_features}}
  - **インストール時初期化**: {{install_actions}}
  - **メッセージタイプ**: {{message_types}}

  ## イベントリスナー
  {{#if install_actions}}
  - chrome.runtime.onInstalled: 初期化処理、右クリックメニュー登録
  {{/if}}
  {{#if background_features.includes('messaging')}}
  - chrome.runtime.onMessage: メッセージ受信・処理
  {{/if}}
  {{#if background_features.includes('tab_monitoring')}}
  - chrome.tabs.onUpdated: タブ更新監視
  {{/if}}
  {{#if use_alarms_api}}
  - chrome.alarms.onAlarm: 定期実行タスク（{{alarm_interval}}分間隔）
  {{/if}}
  {{#if use_context_menu}}
  - chrome.contextMenus.onClicked: 右クリックメニュー処理
  {{/if}}

  ## 状態管理
  - Chrome Storage API（chrome.storage.sync）で設定を永続化
  - Service Worker再起動時に状態を復元

  ## Manifest V2からの移行ポイント
  - background.scripts → background.service_worker
  - 永続的バックグラウンドページ → イベント駆動型Service Worker
  - setInterval/setTimeout → chrome.alarms API

  ## 連携コンポーネント
  - Popup UI: メッセージ送受信（03_chrome_extension_popup.mdc）
  - Content Script: メッセージ送受信（05_chrome_extension_content.mdc）

  ## ファイル
  - src/js/background.js

  ## 次のステップ
  1. Chrome開発者モードで拡張機能を読み込み
  2. Service Workerのコンソールログを確認
  3. メッセージング動作確認
  4. 定期実行タスク動作確認（該当する場合）

  ---
  **保存先**: Flow/{{meta.year_month}}/{{meta.today}}/background_memo_{{meta.today}}.md

# ======== エラーハンドリング ========

error_handling:
  service_worker_inactive:
    message: "Service Workerがアイドル状態で停止しました。"
    recovery_actions:
      - "重要な状態をChrome Storage APIで永続化"
      - "イベントリスナーをトップレベルで登録し、Service Worker再起動時に自動登録"

  message_response_timeout:
    message: "メッセージレスポンスがタイムアウトしました。"
    recovery_actions:
      - "非同期処理の場合は return true を記述してsendResponseを非同期で返す"
      - "タイムアウト時間を考慮した処理設計"

# ======== 設定 ========

background_settings:
  service_worker_type: "module"
  default_alarm_interval: 5
  storage_type: "sync"

# ======== 統合ポイント ========

integration_points:
  popup_messaging:
    trigger: "background_features に messaging が含まれる場合"
    action: "call 03_chrome_extension_popup.mdc"

  content_messaging:
    trigger: "tab_monitoring または messaging が有効な場合"
    action: "call 05_chrome_extension_content.mdc"

  testing:
    trigger: "実装完了後"
    action: "call 07_chrome_extension_testing.mdc"

# ======== 品質保証 ========

quality_assurance:
  mandatory_checks:
    - "イベントリスナーがトップレベルで登録されていること"
    - "非同期処理に async/await を使用していること"
    - "chrome.runtime.onMessage で return true を記述していること（非同期レスポンス時）"
    - "重要な状態がChrome Storage APIで永続化されていること"

# ======== 成功メトリクス ========

success_metrics:
  - "Service Worker起動時間 < 1秒"
  - "メッセージ処理成功率 = 100%"
  - "Alarms API実行精度 > 95%"
  - "Service Worker再起動時の状態復元成功率 = 100%"
