# サブエージェント設計ガイド

## 基本原則

### サブエージェントとは
- **コンテキストを保持せずに独立実行できるタスク**を担当するエージェント
- 親エージェントから呼び出され、結果のみを返す
- 専門的なSkillsを携帯し、特定領域に特化

### サブエージェント化のメリット
1. **並列実行**: 複数のサブエージェントを同時実行可能
2. **専門性分離**: 各サブエージェントが特定領域に集中
3. **コンテキスト節約**: 親のコンテキストを消費しない
4. **再利用性**: 複数のSkillsから呼び出し可能

## サブエージェント化の判定基準

### ✅ サブエージェント化すべきケース

| ケース | 理由 | 例 |
|--------|------|-----|
| Web検索・情報収集 | 非同期実行可能、コンテキスト不要 | 最新ドキュメント調査 |
| 並列レビュー | 複数ファイルを同時チェック可能 | コードレビュー |
| アイデア出し | 複数観点を並列生成 | 設計案ブレスト |
| 仮説検証 | 独立した検証プロセス | 実現可能性調査 |
| 専門分析 | 深い専門知識が必要 | セキュリティ監査 |
| フィードバック | 客観的な第三者視点 | 成果物レビュー |

### ❌ サブエージェント化すべきでないケース

| ケース | 理由 | 代替手段 |
|--------|------|----------|
| 単純なチェックリスト確認 | evaluation/*.mdで十分 | evaluation基準 |
| 親コンテキスト必須の判断 | サブエージェント化の意味なし | 親エージェントで実行 |
| 連続的な対話が必要 | コンテキスト保持が必要 | 親エージェントで実行 |
| 軽微な検証 | オーバーヘッドが大きい | インライン実行 |

## 携帯Skillsの設計

### 携帯Skillsとは
- サブエージェントが参照・実行できるSkills
- サブエージェント定義内で明示的に指定
- サブエージェントの専門性を決定

### 携帯Skills選定基準
1. **関連性**: サブエージェントのタスクに直接関連
2. **独立性**: 親コンテキストなしで実行可能
3. **完結性**: 携帯Skillsだけでタスク完了可能

### 例: feedback-agentの携帯Skills
```yaml
携帯Skills:
  - custom-function: 評価対象のFunction実装知識
  - error-handling: エラーハンドリングのベストプラクティス
  - testing: テスト観点の知識
```

## サブエージェントタイプ

### 1. research-agent（調査系）
- **目的**: 最新情報・ベストプラクティスの収集
- **ツール**: WebSearch, WebFetch, Read
- **並列実行**: 可能
- **出力**: 調査レポート

### 2. feedback-agent（フィードバック系）
- **目的**: 成果物の客観的レビュー
- **ツール**: Read, Grep, Glob
- **並列実行**: 可能（複数ファイル）
- **出力**: レビューコメント、改善提案

### 3. ideation-agent（アイデア出し系）
- **目的**: 複数アプローチの並列生成
- **ツール**: Read, WebSearch
- **並列実行**: 可能（複数観点）
- **出力**: アイデアリスト、比較表

### 4. validation-agent（検証系）
- **目的**: 仮説・設計の妥当性検証
- **ツール**: Read, Grep, Bash
- **並列実行**: 可能
- **出力**: 検証結果、リスク一覧

### 5. parallel-check-agent（並列チェック系）
- **目的**: 複数ファイルの同時チェック
- **ツール**: Read, Grep, Glob
- **並列実行**: 必須
- **出力**: チェック結果一覧

## 入出力設計

### 入力設計のポイント
- **必要最小限**: 親コンテキストに依存しない情報のみ
- **明確なスコープ**: 何をチェック/調査するか明確に
- **ファイルパス**: 対象ファイルのパスを明示

### 出力設計のポイント
- **構造化**: JSON/Markdown等の構造化フォーマット
- **アクショナブル**: 次のアクションが明確
- **優先度付き**: 重要度・緊急度を付与
